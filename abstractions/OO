h1. Object Oriented Abstractions

Where had I gone wrong? I could feel the frustration building up as I sat there on this little round table, glaring at my laptop screen. Amid the chatter of happy customers and the clanking of coffee cups as the waitress was clearing up the tables, I sat back in disgust. Computers don't lie, and they don't care if they hurt your feeling. The truth was undisputable: my tests were failing. Way too many tests were failing. I didn't understand; this was supposed to be a simple little feature. This was supposed to take me a tiny five minutes to implement. Instead, my coffee was already cold and I shivered thinking of how long it would take me to refactor everything.

h2. My code sucked.

How could it be? I was doing TDD! I was programming in Ruby! I'm a smart professional! I've done this before! With a sigh, I sat back and turned my computer off. I was done for the day and needed to cool off anyway. I had screwed up and I knew it. I felt... unworthy of being called a programmer. But worst of all, I knew deep inside that my code sucked.

Over the next few weeks I wouldn't be able to get this feeling out of my head. Why did the code suck? The answer didn't take very long to come: although I had been doing TDD, I had been doing it without regards to building proper abstractions. I had been religiously following the green-red-refactor technique, but my refactorings had simply been about removing code duplication. It was a small app: an offline blog manager. Something so simple in nature that I got lulled into thinking that design wouldn't be as important. It wasn't pretty: two classes out of four were manager classes that had multiple responsibilities and my most important abstraction, a blog post, was reduced to being a collection of hashes maintained by one of the managers.

The funny thing is that this wasn't the first time this had happened to me. In my first job out of college I designed and wrote a plugin that would automate the design and assembly of mechanical parts in a CAD software. It was a complicated little plugin, but early on in its implementation I had made that exact same mistake. I hadn't properly abstracted the most important concept of our domain. This ended up costing thousands of dollars to the company in refactoring time after we hit the wall and realized the gross enormity of what we had done. Eight years later, I still had not learned, but at least this time around the lesson was less painful and I only got a bruised ego.

My code sucked, so I bit the bullet and started over. I deleted everything and started from scratch. This time, however, I'd pay attention to object oriented programming principles and proper abstractions, because every time I've done so in the past, my code improved. It also got me thinking about abstractions in general. What is a proper abstraction? What is the proper way to split out your code into modules? Is there even a proper way? Is the lack of abstractions the reason I wasn't able to add a simple feature to my project in a reasonable amount of time? 

h2. Abstractions

Since the beginning of time, programmers around the world have been striving to modularize their "code":http://en.wikipedia.org/wiki/Modular_programming ==[1]==. Code reuse, separation of concern, task separation between team members and maintainability are usually the reasons behind the effort, and for a good reason: modularization has been shown to be effective, despite the fact that there is still room for improvement ==[2]==. This effectiveness comes from the cohesiveness of the modules themselves. As bugs are fixed or new features are added, the changes in the code base are restricted to the area of the module and require less knowledge about other modules. 

Different techniques that can be used to organize our abstractions, and some are better than others. Even though I was using an object oriented programming language, my own naive attempt is proof that without careful consideration, things can go downhill quite fast. Objects (or classes) alone, while providing a way to modularize your code, are not enough and certainly aren't the only way to "do so":http://www.cs.ubc.ca/~gregor/papers/kiczales-ECOOP1997-AOP.pdf ==[3]==. Without regards to techniques, however, this "paper":http://sunnyday.mit.edu/16.355/parnas-criteria.html ==[4]== provide me with some great insight into the fact that there is more to modularization than meets the eye. I greatly encourage you to read that paper, as it has been cited by 932 other research papers about modularization, including some as recent as "2010":http://citeseer.ist.psu.edu/viewauth/summary?aid=590098 ==[5]==. In the text, the author proposes that modules hide design decisions from other modules, which sounds straight forward, except that it's really not. As a system is designed, attention must be put on the parts of the system where you are not quite sure how things will evolve. This uncertainty is a sure sign of the possibility that design details will change in that area. By isolating it from the rest of the code, you are making sure that as those changes come, the rest of the code will have a greater chance of remaining unchanged. 

Oren Eini, aka "Ayende":http://ayende.com/blog/default.aspx ==[6]==, is a successful software developer whoes contributions to the .Net world haven't gone "unnoticed":http://skillsmatter.com/expert/open-source-dot-net/ayende-rahien-oren-eini ==[7]==. He is considered an extremely productive developer because of his "focus":http://ayende.com/Blog/archive/2009/03/06/application-structure-concepts-amp-features.aspx on architecture and friction points in the applications he's involved with ==[8]==. This, in turn, has allowed him and the other developers he works with to increase the pace at which they release new features and bug fixes. Given his track record, it seems natural that his practices should be emulated by other C# and enterprise programmers. You might observe that there is an almost 40 year gap between now and when Parnas wrote his paper in 1972. Today's software development is done in an agile fashion, with less design up front and quick, successive iterations that rapidely indicate flaws and pain points in our designs. Consequently, uncertainty in our designs might not be apparent until we are well under way in our coding effort, as it happened to me. Unfortunately, I was made aware of my mistakes too late. Or rather, I could have known about them much earlier. Constant attention to pain points would have helped in retrospect.

h2. Going Forward

This post isn't bringing anything new to the table. It is instead meant to provide a starting point for those interesting in thinking about modularization as a way to improve programmer's productivity as an app is being written. I personally have yet to learn those lessons despite having been caught multiple times in a re-design quagmire. There is definately a need to be incredibly sensitive to pain points in order to identify risky areas as soon as possible, before too much code is written. Then the design of the app might have to be modified in order to isolate those risky and fuzzy areas. I'd be willing to call this extra work an investment that with practice and experience would yield the developer better and better ROIs over time.

h2. References

# Modular Programming, wikipedia, "http://en.wikipedia.org/wiki/Modular_programming":http://en.wikipedia.org/wiki/Modular_programming
# How Effective is Modularization?, Neil Thomas, Gail Murphy, Making Software, p. 373
# Aspect Oriented Programming, Kiczales G., et al., 1997, "http://www.cs.ubc.ca/~gregor/papers/kiczales-ECOOP1997-AOP.pdf":http://www.cs.ubc.ca/~gregor/papers/kiczales-ECOOP1997-AOP.pdf
# On the Criteria To Be Used in Decomposing Systems into Modules, D.L. Parnas, "http://sunnyday.mit.edu/16.355/parnas-criteria.html":http://sunnyday.mit.edu/16.355/parnas-criteria.html
# Citeseer search, "http://citeseer.ist.psu.edu/viewauth/summary?aid=590098":http://citeseer.ist.psu.edu/viewauth/summary?aid=590098
# Ayende's blog, "http://ayende.com/blog/default.aspx":http://ayende.com/blog/default.aspx
# "http://skillsmatter.com/expert/open-source-dot-net/ayende-rahien-oren-eini":http://skillsmatter.com/expert/open-source-dot-net/ayende-rahien-oren-eini
# Application Structure: Concepts & Features, "http://ayende.com/Blog/archive/2009/03/06/application-structure-concepts-amp-features.aspx":http://ayende.com/Blog/archive/2009/03/06/application-structure-concepts-amp-features.aspx
